# DPQ 1-15-2016

**Today's lecture contained a chart estimating the growth rate of some nested loops. Justify the two estimates that appear in boldface.**

The following algorithm is justified as O(n^4): for (int i = 1; i < n*n; i++) for (int j = 0; j < i; j++) The outer loop's iteration count can be denoted as O(n^2) and within the inner loop, we can see how j's iteration count is determined by i, which bounds up to n*n, thus O(n^2). Therefore, by multiplying these two inner complexities together, we obtain that f(x) = n^2 * n^2 or n^4, therefore this first code is justified as O(n^4). The following algorithm is justified as O(n^2): for (int i = 1; i < n*n; i++) for (int j = i; j < n; j++) As with the previous analysis, we have concluded that the execution of the outer loop is on the order of O(n^2). However, within the inner for loop, the i is now being dependent on not the conditional section, but the initialization of the starting point of the for loop. Concretely, let's consider the case where n is 3: Let n = 3 for 1 -> 3^3 (or 27), we have the following table of values: i j inner_count 1 1 2 2 2 1 3 3 None or 0 4 4 None or 0 ... ... ... As we can see above from this concrete example, the inner loop doesn't even execute at all beyond the point when i is greater than or equal to n. Because of this, we find that the inner loop does not contribute any significant weight in terms of execution counts. Therefore, this justifies that the overall performance for this loop is can be determined as O(n^2).

> First answer is fine; second is incomplete. It is good to note that the inner loop stops repeating when i exceeds n, but one should still account for its contribution before then. (1.0/1.0)
